/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-virtual";
exports.ids = ["vendor-chunks/react-virtual"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-virtual/dist/react-virtual.development.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-virtual/dist/react-virtual.development.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\")) :\n  0;\n}(this, (function (exports, React) { 'use strict';\n\n  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\n  var rectChanged = function rectChanged(a, b) {\n    if (a === void 0) {\n      a = {};\n    }\n\n    if (b === void 0) {\n      b = {};\n    }\n\n    return props.some(function (prop) {\n      return a[prop] !== b[prop];\n    });\n  };\n\n  var observedNodes = /*#__PURE__*/new Map();\n  var rafId;\n\n  var run = function run() {\n    var changedStates = [];\n    observedNodes.forEach(function (state, node) {\n      var newRect = node.getBoundingClientRect();\n\n      if (rectChanged(newRect, state.rect)) {\n        state.rect = newRect;\n        changedStates.push(state);\n      }\n    });\n    changedStates.forEach(function (state) {\n      state.callbacks.forEach(function (cb) {\n        return cb(state.rect);\n      });\n    });\n    rafId = window.requestAnimationFrame(run);\n  };\n\n  function observeRect(node, cb) {\n    return {\n      observe: function observe() {\n        var wasEmpty = observedNodes.size === 0;\n\n        if (observedNodes.has(node)) {\n          observedNodes.get(node).callbacks.push(cb);\n        } else {\n          observedNodes.set(node, {\n            rect: undefined,\n            hasRectChanged: false,\n            callbacks: [cb]\n          });\n        }\n\n        if (wasEmpty) run();\n      },\n      unobserve: function unobserve() {\n        var state = observedNodes.get(node);\n\n        if (state) {\n          // Remove the callback\n          var index = state.callbacks.indexOf(cb);\n          if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n          if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n          if (!observedNodes.size) cancelAnimationFrame(rafId);\n        }\n      }\n    };\n  }\n\n  var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\n  function useRect(nodeRef, initialRect) {\n    if (initialRect === void 0) {\n      initialRect = {\n        width: 0,\n        height: 0\n      };\n    }\n\n    var _React$useState = React.useState(nodeRef.current),\n        element = _React$useState[0],\n        setElement = _React$useState[1];\n\n    var _React$useReducer = React.useReducer(rectReducer, initialRect),\n        rect = _React$useReducer[0],\n        dispatch = _React$useReducer[1];\n\n    var initialRectSet = React.useRef(false);\n    useIsomorphicLayoutEffect(function () {\n      if (nodeRef.current !== element) {\n        setElement(nodeRef.current);\n      }\n    });\n    useIsomorphicLayoutEffect(function () {\n      if (element && !initialRectSet.current) {\n        initialRectSet.current = true;\n\n        var _rect = element.getBoundingClientRect();\n\n        dispatch({\n          rect: _rect\n        });\n      }\n    }, [element]);\n    React.useEffect(function () {\n      if (!element) {\n        return;\n      }\n\n      var observer = observeRect(element, function (rect) {\n        dispatch({\n          rect: rect\n        });\n      });\n      observer.observe();\n      return function () {\n        observer.unobserve();\n      };\n    }, [element]);\n    return rect;\n  }\n\n  function rectReducer(state, action) {\n    var rect = action.rect;\n\n    if (state.height !== rect.height || state.width !== rect.width) {\n      return rect;\n    }\n\n    return state;\n  }\n\n  var defaultEstimateSize = function defaultEstimateSize() {\n    return 50;\n  };\n\n  var defaultKeyExtractor = function defaultKeyExtractor(index) {\n    return index;\n  };\n\n  var defaultMeasureSize = function defaultMeasureSize(el, horizontal) {\n    var key = horizontal ? 'offsetWidth' : 'offsetHeight';\n    return el[key];\n  };\n\n  var defaultRangeExtractor = function defaultRangeExtractor(range) {\n    var start = Math.max(range.start - range.overscan, 0);\n    var end = Math.min(range.end + range.overscan, range.size - 1);\n    var arr = [];\n\n    for (var i = start; i <= end; i++) {\n      arr.push(i);\n    }\n\n    return arr;\n  };\n  function useVirtual(_ref) {\n    var _measurements;\n\n    var _ref$size = _ref.size,\n        size = _ref$size === void 0 ? 0 : _ref$size,\n        _ref$estimateSize = _ref.estimateSize,\n        estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize,\n        _ref$overscan = _ref.overscan,\n        overscan = _ref$overscan === void 0 ? 1 : _ref$overscan,\n        _ref$paddingStart = _ref.paddingStart,\n        paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart,\n        _ref$paddingEnd = _ref.paddingEnd,\n        paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd,\n        parentRef = _ref.parentRef,\n        horizontal = _ref.horizontal,\n        scrollToFn = _ref.scrollToFn,\n        useObserver = _ref.useObserver,\n        initialRect = _ref.initialRect,\n        onScrollElement = _ref.onScrollElement,\n        scrollOffsetFn = _ref.scrollOffsetFn,\n        _ref$keyExtractor = _ref.keyExtractor,\n        keyExtractor = _ref$keyExtractor === void 0 ? defaultKeyExtractor : _ref$keyExtractor,\n        _ref$measureSize = _ref.measureSize,\n        measureSize = _ref$measureSize === void 0 ? defaultMeasureSize : _ref$measureSize,\n        _ref$rangeExtractor = _ref.rangeExtractor,\n        rangeExtractor = _ref$rangeExtractor === void 0 ? defaultRangeExtractor : _ref$rangeExtractor;\n    var sizeKey = horizontal ? 'width' : 'height';\n    var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';\n    var latestRef = React.useRef({\n      scrollOffset: 0,\n      measurements: []\n    });\n\n    var _React$useState = React.useState(0),\n        scrollOffset = _React$useState[0],\n        setScrollOffset = _React$useState[1];\n\n    latestRef.current.scrollOffset = scrollOffset;\n    var useMeasureParent = useObserver || useRect;\n\n    var _useMeasureParent = useMeasureParent(parentRef, initialRect),\n        outerSize = _useMeasureParent[sizeKey];\n\n    latestRef.current.outerSize = outerSize;\n    var defaultScrollToFn = React.useCallback(function (offset) {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset;\n      }\n    }, [parentRef, scrollKey]);\n    var resolvedScrollToFn = scrollToFn || defaultScrollToFn;\n    scrollToFn = React.useCallback(function (offset) {\n      resolvedScrollToFn(offset, defaultScrollToFn);\n    }, [defaultScrollToFn, resolvedScrollToFn]);\n\n    var _React$useState2 = React.useState({}),\n        measuredCache = _React$useState2[0],\n        setMeasuredCache = _React$useState2[1];\n\n    var measure = React.useCallback(function () {\n      return setMeasuredCache({});\n    }, []);\n    var pendingMeasuredCacheIndexesRef = React.useRef([]);\n    var measurements = React.useMemo(function () {\n      var min = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;\n      pendingMeasuredCacheIndexesRef.current = [];\n      var measurements = latestRef.current.measurements.slice(0, min);\n\n      for (var i = min; i < size; i++) {\n        var key = keyExtractor(i);\n        var measuredSize = measuredCache[key];\n\n        var _start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n\n        var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(i);\n\n        var _end = _start + _size;\n\n        measurements[i] = {\n          index: i,\n          start: _start,\n          size: _size,\n          end: _end,\n          key: key\n        };\n      }\n\n      return measurements;\n    }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);\n    var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || paddingStart) + paddingEnd;\n    latestRef.current.measurements = measurements;\n    latestRef.current.totalSize = totalSize;\n    var element = onScrollElement ? onScrollElement.current : parentRef.current;\n    var scrollOffsetFnRef = React.useRef(scrollOffsetFn);\n    scrollOffsetFnRef.current = scrollOffsetFn;\n    useIsomorphicLayoutEffect(function () {\n      if (!element) {\n        setScrollOffset(0);\n        return;\n      }\n\n      var onScroll = function onScroll(event) {\n        var offset = scrollOffsetFnRef.current ? scrollOffsetFnRef.current(event) : element[scrollKey];\n        setScrollOffset(offset);\n      };\n\n      onScroll();\n      element.addEventListener('scroll', onScroll, {\n        capture: false,\n        passive: true\n      });\n      return function () {\n        element.removeEventListener('scroll', onScroll);\n      };\n    }, [element, scrollKey]);\n\n    var _calculateRange = calculateRange(latestRef.current),\n        start = _calculateRange.start,\n        end = _calculateRange.end;\n\n    var indexes = React.useMemo(function () {\n      return rangeExtractor({\n        start: start,\n        end: end,\n        overscan: overscan,\n        size: measurements.length\n      });\n    }, [start, end, overscan, measurements.length, rangeExtractor]);\n    var measureSizeRef = React.useRef(measureSize);\n    measureSizeRef.current = measureSize;\n    var virtualItems = React.useMemo(function () {\n      var virtualItems = [];\n\n      var _loop = function _loop(k, len) {\n        var i = indexes[k];\n        var measurement = measurements[i];\n\n        var item = _extends(_extends({}, measurement), {}, {\n          measureRef: function measureRef(el) {\n            if (el) {\n              var measuredSize = measureSizeRef.current(el, horizontal);\n\n              if (measuredSize !== item.size) {\n                var _scrollOffset = latestRef.current.scrollOffset;\n\n                if (item.start < _scrollOffset) {\n                  defaultScrollToFn(_scrollOffset + (measuredSize - item.size));\n                }\n\n                pendingMeasuredCacheIndexesRef.current.push(i);\n                setMeasuredCache(function (old) {\n                  var _extends2;\n\n                  return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));\n                });\n              }\n            }\n          }\n        });\n\n        virtualItems.push(item);\n      };\n\n      for (var k = 0, len = indexes.length; k < len; k++) {\n        _loop(k);\n      }\n\n      return virtualItems;\n    }, [indexes, defaultScrollToFn, horizontal, measurements]);\n    var mountedRef = React.useRef(false);\n    useIsomorphicLayoutEffect(function () {\n      if (mountedRef.current) {\n        setMeasuredCache({});\n      }\n\n      mountedRef.current = true;\n    }, [estimateSize]);\n    var scrollToOffset = React.useCallback(function (toOffset, _temp) {\n      var _ref2 = _temp === void 0 ? {} : _temp,\n          _ref2$align = _ref2.align,\n          align = _ref2$align === void 0 ? 'start' : _ref2$align;\n\n      var _latestRef$current = latestRef.current,\n          scrollOffset = _latestRef$current.scrollOffset,\n          outerSize = _latestRef$current.outerSize;\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start';\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end';\n        } else {\n          align = 'start';\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset);\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize);\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2);\n      }\n    }, [scrollToFn]);\n    var tryScrollToIndex = React.useCallback(function (index, _temp2) {\n      var _ref3 = _temp2 === void 0 ? {} : _temp2,\n          _ref3$align = _ref3.align,\n          align = _ref3$align === void 0 ? 'auto' : _ref3$align,\n          rest = _objectWithoutPropertiesLoose(_ref3, [\"align\"]);\n\n      var _latestRef$current2 = latestRef.current,\n          measurements = _latestRef$current2.measurements,\n          scrollOffset = _latestRef$current2.scrollOffset,\n          outerSize = _latestRef$current2.outerSize;\n      var measurement = measurements[Math.max(0, Math.min(index, size - 1))];\n\n      if (!measurement) {\n        return;\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end';\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start';\n        } else {\n          return;\n        }\n      }\n\n      var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;\n      scrollToOffset(toOffset, _extends({\n        align: align\n      }, rest));\n    }, [scrollToOffset, size]);\n    var scrollToIndex = React.useCallback(function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex.apply(void 0, args);\n      requestAnimationFrame(function () {\n        tryScrollToIndex.apply(void 0, args);\n      });\n    }, [tryScrollToIndex]);\n    return {\n      virtualItems: virtualItems,\n      totalSize: totalSize,\n      scrollToOffset: scrollToOffset,\n      scrollToIndex: scrollToIndex,\n      measure: measure\n    };\n  }\n\n  var findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n    while (low <= high) {\n      var middle = (low + high) / 2 | 0;\n      var currentValue = getCurrentValue(middle);\n\n      if (currentValue < value) {\n        low = middle + 1;\n      } else if (currentValue > value) {\n        high = middle - 1;\n      } else {\n        return middle;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    } else {\n      return 0;\n    }\n  };\n\n  function calculateRange(_ref4) {\n    var measurements = _ref4.measurements,\n        outerSize = _ref4.outerSize,\n        scrollOffset = _ref4.scrollOffset;\n    var size = measurements.length - 1;\n\n    var getOffset = function getOffset(index) {\n      return measurements[index].start;\n    };\n\n    var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);\n    var end = start;\n\n    while (end < size && measurements[end].end < scrollOffset + outerSize) {\n      end++;\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  exports.defaultRangeExtractor = defaultRangeExtractor;\n  exports.useVirtual = useVirtual;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=react-virtual.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVhbC9kaXN0L3JlYWN0LXZpcnR1YWwuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHdHQUFPO0FBQ2pHLEVBQUUsQ0FDd0U7QUFDMUUsQ0FBQyxvQ0FBb0M7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQsc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsVUFBVSxpQkFBaUI7QUFDeEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFpcmMvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVhbC9kaXN0L3JlYWN0LXZpcnR1YWwuZGV2ZWxvcG1lbnQuanM/Mzg1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3JlYWN0JykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuUmVhY3RRdWVyeSA9IHt9LCBnbG9iYWwuUmVhY3QpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBSZWFjdCkgeyAndXNlIHN0cmljdCc7XG5cbiAgUmVhY3QgPSBSZWFjdCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUmVhY3QsICdkZWZhdWx0JykgPyBSZWFjdFsnZGVmYXVsdCddIDogUmVhY3Q7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSBbJ2JvdHRvbScsICdoZWlnaHQnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnd2lkdGgnXTtcblxuICB2YXIgcmVjdENoYW5nZWQgPSBmdW5jdGlvbiByZWN0Q2hhbmdlZChhLCBiKSB7XG4gICAgaWYgKGEgPT09IHZvaWQgMCkge1xuICAgICAgYSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChiID09PSB2b2lkIDApIHtcbiAgICAgIGIgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMuc29tZShmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIGFbcHJvcF0gIT09IGJbcHJvcF07XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG9ic2VydmVkTm9kZXMgPSAvKiNfX1BVUkVfXyovbmV3IE1hcCgpO1xuICB2YXIgcmFmSWQ7XG5cbiAgdmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICB2YXIgY2hhbmdlZFN0YXRlcyA9IFtdO1xuICAgIG9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUsIG5vZGUpIHtcbiAgICAgIHZhciBuZXdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHJlY3RDaGFuZ2VkKG5ld1JlY3QsIHN0YXRlLnJlY3QpKSB7XG4gICAgICAgIHN0YXRlLnJlY3QgPSBuZXdSZWN0O1xuICAgICAgICBjaGFuZ2VkU3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNoYW5nZWRTdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHN0YXRlLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXR1cm4gY2Ioc3RhdGUucmVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKTtcbiAgfTtcblxuICBmdW5jdGlvbiBvYnNlcnZlUmVjdChub2RlLCBjYikge1xuICAgIHJldHVybiB7XG4gICAgICBvYnNlcnZlOiBmdW5jdGlvbiBvYnNlcnZlKCkge1xuICAgICAgICB2YXIgd2FzRW1wdHkgPSBvYnNlcnZlZE5vZGVzLnNpemUgPT09IDA7XG5cbiAgICAgICAgaWYgKG9ic2VydmVkTm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgb2JzZXJ2ZWROb2Rlcy5nZXQobm9kZSkuY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ic2VydmVkTm9kZXMuc2V0KG5vZGUsIHtcbiAgICAgICAgICAgIHJlY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhhc1JlY3RDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogW2NiXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdhc0VtcHR5KSBydW4oKTtcbiAgICAgIH0sXG4gICAgICB1bm9ic2VydmU6IGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gb2JzZXJ2ZWROb2Rlcy5nZXQobm9kZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjYWxsYmFja1xuICAgICAgICAgIHZhciBpbmRleCA9IHN0YXRlLmNhbGxiYWNrcy5pbmRleE9mKGNiKTtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkgc3RhdGUuY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7IC8vIFJlbW92ZSB0aGUgbm9kZSByZWZlcmVuY2VcblxuICAgICAgICAgIGlmICghc3RhdGUuY2FsbGJhY2tzLmxlbmd0aCkgb2JzZXJ2ZWROb2Rlc1tcImRlbGV0ZVwiXShub2RlKTsgLy8gU3RvcCB0aGUgbG9vcFxuXG4gICAgICAgICAgaWYgKCFvYnNlcnZlZE5vZGVzLnNpemUpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG4gIGZ1bmN0aW9uIHVzZVJlY3Qobm9kZVJlZiwgaW5pdGlhbFJlY3QpIHtcbiAgICBpZiAoaW5pdGlhbFJlY3QgPT09IHZvaWQgMCkge1xuICAgICAgaW5pdGlhbFJlY3QgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG5vZGVSZWYuY3VycmVudCksXG4gICAgICAgIGVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICAgIHNldEVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgICB2YXIgX1JlYWN0JHVzZVJlZHVjZXIgPSBSZWFjdC51c2VSZWR1Y2VyKHJlY3RSZWR1Y2VyLCBpbml0aWFsUmVjdCksXG4gICAgICAgIHJlY3QgPSBfUmVhY3QkdXNlUmVkdWNlclswXSxcbiAgICAgICAgZGlzcGF0Y2ggPSBfUmVhY3QkdXNlUmVkdWNlclsxXTtcblxuICAgIHZhciBpbml0aWFsUmVjdFNldCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobm9kZVJlZi5jdXJyZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgIHNldEVsZW1lbnQobm9kZVJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbGVtZW50ICYmICFpbml0aWFsUmVjdFNldC5jdXJyZW50KSB7XG4gICAgICAgIGluaXRpYWxSZWN0U2V0LmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBfcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHJlY3Q6IF9yZWN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IG9ic2VydmVSZWN0KGVsZW1lbnQsIGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICByZWN0OiByZWN0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbiAgICAgIH07XG4gICAgfSwgW2VsZW1lbnRdKTtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY3RSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICB2YXIgcmVjdCA9IGFjdGlvbi5yZWN0O1xuXG4gICAgaWYgKHN0YXRlLmhlaWdodCAhPT0gcmVjdC5oZWlnaHQgfHwgc3RhdGUud2lkdGggIT09IHJlY3Qud2lkdGgpIHtcbiAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0RXN0aW1hdGVTaXplID0gZnVuY3Rpb24gZGVmYXVsdEVzdGltYXRlU2l6ZSgpIHtcbiAgICByZXR1cm4gNTA7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRLZXlFeHRyYWN0b3IgPSBmdW5jdGlvbiBkZWZhdWx0S2V5RXh0cmFjdG9yKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIHZhciBkZWZhdWx0TWVhc3VyZVNpemUgPSBmdW5jdGlvbiBkZWZhdWx0TWVhc3VyZVNpemUoZWwsIGhvcml6b250YWwpIHtcbiAgICB2YXIga2V5ID0gaG9yaXpvbnRhbCA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0JztcbiAgICByZXR1cm4gZWxba2V5XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdFJhbmdlRXh0cmFjdG9yID0gZnVuY3Rpb24gZGVmYXVsdFJhbmdlRXh0cmFjdG9yKHJhbmdlKSB7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQgLSByYW5nZS5vdmVyc2NhbiwgMCk7XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHJhbmdlLmVuZCArIHJhbmdlLm92ZXJzY2FuLCByYW5nZS5zaXplIC0gMSk7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xuICB9O1xuICBmdW5jdGlvbiB1c2VWaXJ0dWFsKF9yZWYpIHtcbiAgICB2YXIgX21lYXN1cmVtZW50cztcblxuICAgIHZhciBfcmVmJHNpemUgPSBfcmVmLnNpemUsXG4gICAgICAgIHNpemUgPSBfcmVmJHNpemUgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHNpemUsXG4gICAgICAgIF9yZWYkZXN0aW1hdGVTaXplID0gX3JlZi5lc3RpbWF0ZVNpemUsXG4gICAgICAgIGVzdGltYXRlU2l6ZSA9IF9yZWYkZXN0aW1hdGVTaXplID09PSB2b2lkIDAgPyBkZWZhdWx0RXN0aW1hdGVTaXplIDogX3JlZiRlc3RpbWF0ZVNpemUsXG4gICAgICAgIF9yZWYkb3ZlcnNjYW4gPSBfcmVmLm92ZXJzY2FuLFxuICAgICAgICBvdmVyc2NhbiA9IF9yZWYkb3ZlcnNjYW4gPT09IHZvaWQgMCA/IDEgOiBfcmVmJG92ZXJzY2FuLFxuICAgICAgICBfcmVmJHBhZGRpbmdTdGFydCA9IF9yZWYucGFkZGluZ1N0YXJ0LFxuICAgICAgICBwYWRkaW5nU3RhcnQgPSBfcmVmJHBhZGRpbmdTdGFydCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkcGFkZGluZ1N0YXJ0LFxuICAgICAgICBfcmVmJHBhZGRpbmdFbmQgPSBfcmVmLnBhZGRpbmdFbmQsXG4gICAgICAgIHBhZGRpbmdFbmQgPSBfcmVmJHBhZGRpbmdFbmQgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHBhZGRpbmdFbmQsXG4gICAgICAgIHBhcmVudFJlZiA9IF9yZWYucGFyZW50UmVmLFxuICAgICAgICBob3Jpem9udGFsID0gX3JlZi5ob3Jpem9udGFsLFxuICAgICAgICBzY3JvbGxUb0ZuID0gX3JlZi5zY3JvbGxUb0ZuLFxuICAgICAgICB1c2VPYnNlcnZlciA9IF9yZWYudXNlT2JzZXJ2ZXIsXG4gICAgICAgIGluaXRpYWxSZWN0ID0gX3JlZi5pbml0aWFsUmVjdCxcbiAgICAgICAgb25TY3JvbGxFbGVtZW50ID0gX3JlZi5vblNjcm9sbEVsZW1lbnQsXG4gICAgICAgIHNjcm9sbE9mZnNldEZuID0gX3JlZi5zY3JvbGxPZmZzZXRGbixcbiAgICAgICAgX3JlZiRrZXlFeHRyYWN0b3IgPSBfcmVmLmtleUV4dHJhY3RvcixcbiAgICAgICAga2V5RXh0cmFjdG9yID0gX3JlZiRrZXlFeHRyYWN0b3IgPT09IHZvaWQgMCA/IGRlZmF1bHRLZXlFeHRyYWN0b3IgOiBfcmVmJGtleUV4dHJhY3RvcixcbiAgICAgICAgX3JlZiRtZWFzdXJlU2l6ZSA9IF9yZWYubWVhc3VyZVNpemUsXG4gICAgICAgIG1lYXN1cmVTaXplID0gX3JlZiRtZWFzdXJlU2l6ZSA9PT0gdm9pZCAwID8gZGVmYXVsdE1lYXN1cmVTaXplIDogX3JlZiRtZWFzdXJlU2l6ZSxcbiAgICAgICAgX3JlZiRyYW5nZUV4dHJhY3RvciA9IF9yZWYucmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgIHJhbmdlRXh0cmFjdG9yID0gX3JlZiRyYW5nZUV4dHJhY3RvciA9PT0gdm9pZCAwID8gZGVmYXVsdFJhbmdlRXh0cmFjdG9yIDogX3JlZiRyYW5nZUV4dHJhY3RvcjtcbiAgICB2YXIgc2l6ZUtleSA9IGhvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIHNjcm9sbEtleSA9IGhvcml6b250YWwgPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJztcbiAgICB2YXIgbGF0ZXN0UmVmID0gUmVhY3QudXNlUmVmKHtcbiAgICAgIHNjcm9sbE9mZnNldDogMCxcbiAgICAgIG1lYXN1cmVtZW50czogW11cbiAgICB9KTtcblxuICAgIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSgwKSxcbiAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgICBzZXRTY3JvbGxPZmZzZXQgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgICBsYXRlc3RSZWYuY3VycmVudC5zY3JvbGxPZmZzZXQgPSBzY3JvbGxPZmZzZXQ7XG4gICAgdmFyIHVzZU1lYXN1cmVQYXJlbnQgPSB1c2VPYnNlcnZlciB8fCB1c2VSZWN0O1xuXG4gICAgdmFyIF91c2VNZWFzdXJlUGFyZW50ID0gdXNlTWVhc3VyZVBhcmVudChwYXJlbnRSZWYsIGluaXRpYWxSZWN0KSxcbiAgICAgICAgb3V0ZXJTaXplID0gX3VzZU1lYXN1cmVQYXJlbnRbc2l6ZUtleV07XG5cbiAgICBsYXRlc3RSZWYuY3VycmVudC5vdXRlclNpemUgPSBvdXRlclNpemU7XG4gICAgdmFyIGRlZmF1bHRTY3JvbGxUb0ZuID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgaWYgKHBhcmVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHBhcmVudFJlZi5jdXJyZW50W3Njcm9sbEtleV0gPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfSwgW3BhcmVudFJlZiwgc2Nyb2xsS2V5XSk7XG4gICAgdmFyIHJlc29sdmVkU2Nyb2xsVG9GbiA9IHNjcm9sbFRvRm4gfHwgZGVmYXVsdFNjcm9sbFRvRm47XG4gICAgc2Nyb2xsVG9GbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIHJlc29sdmVkU2Nyb2xsVG9GbihvZmZzZXQsIGRlZmF1bHRTY3JvbGxUb0ZuKTtcbiAgICB9LCBbZGVmYXVsdFNjcm9sbFRvRm4sIHJlc29sdmVkU2Nyb2xsVG9Gbl0pO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZSh7fSksXG4gICAgICAgIG1lYXN1cmVkQ2FjaGUgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgICBzZXRNZWFzdXJlZENhY2hlID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICAgIHZhciBtZWFzdXJlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNldE1lYXN1cmVkQ2FjaGUoe30pO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgcGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgICB2YXIgbWVhc3VyZW1lbnRzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWluID0gcGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzUmVmLmN1cnJlbnQubGVuZ3RoID4gMCA/IE1hdGgubWluLmFwcGx5KE1hdGgsIHBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlc1JlZi5jdXJyZW50KSA6IDA7XG4gICAgICBwZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXNSZWYuY3VycmVudCA9IFtdO1xuICAgICAgdmFyIG1lYXN1cmVtZW50cyA9IGxhdGVzdFJlZi5jdXJyZW50Lm1lYXN1cmVtZW50cy5zbGljZSgwLCBtaW4pO1xuXG4gICAgICBmb3IgKHZhciBpID0gbWluOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlFeHRyYWN0b3IoaSk7XG4gICAgICAgIHZhciBtZWFzdXJlZFNpemUgPSBtZWFzdXJlZENhY2hlW2tleV07XG5cbiAgICAgICAgdmFyIF9zdGFydCA9IG1lYXN1cmVtZW50c1tpIC0gMV0gPyBtZWFzdXJlbWVudHNbaSAtIDFdLmVuZCA6IHBhZGRpbmdTdGFydDtcblxuICAgICAgICB2YXIgX3NpemUgPSB0eXBlb2YgbWVhc3VyZWRTaXplID09PSAnbnVtYmVyJyA/IG1lYXN1cmVkU2l6ZSA6IGVzdGltYXRlU2l6ZShpKTtcblxuICAgICAgICB2YXIgX2VuZCA9IF9zdGFydCArIF9zaXplO1xuXG4gICAgICAgIG1lYXN1cmVtZW50c1tpXSA9IHtcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBzdGFydDogX3N0YXJ0LFxuICAgICAgICAgIHNpemU6IF9zaXplLFxuICAgICAgICAgIGVuZDogX2VuZCxcbiAgICAgICAgICBrZXk6IGtleVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVhc3VyZW1lbnRzO1xuICAgIH0sIFtlc3RpbWF0ZVNpemUsIG1lYXN1cmVkQ2FjaGUsIHBhZGRpbmdTdGFydCwgc2l6ZSwga2V5RXh0cmFjdG9yXSk7XG4gICAgdmFyIHRvdGFsU2l6ZSA9ICgoKF9tZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHNbc2l6ZSAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX21lYXN1cmVtZW50cy5lbmQpIHx8IHBhZGRpbmdTdGFydCkgKyBwYWRkaW5nRW5kO1xuICAgIGxhdGVzdFJlZi5jdXJyZW50Lm1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cztcbiAgICBsYXRlc3RSZWYuY3VycmVudC50b3RhbFNpemUgPSB0b3RhbFNpemU7XG4gICAgdmFyIGVsZW1lbnQgPSBvblNjcm9sbEVsZW1lbnQgPyBvblNjcm9sbEVsZW1lbnQuY3VycmVudCA6IHBhcmVudFJlZi5jdXJyZW50O1xuICAgIHZhciBzY3JvbGxPZmZzZXRGblJlZiA9IFJlYWN0LnVzZVJlZihzY3JvbGxPZmZzZXRGbik7XG4gICAgc2Nyb2xsT2Zmc2V0Rm5SZWYuY3VycmVudCA9IHNjcm9sbE9mZnNldEZuO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHNldFNjcm9sbE9mZnNldCgwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25TY3JvbGwgPSBmdW5jdGlvbiBvblNjcm9sbChldmVudCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gc2Nyb2xsT2Zmc2V0Rm5SZWYuY3VycmVudCA/IHNjcm9sbE9mZnNldEZuUmVmLmN1cnJlbnQoZXZlbnQpIDogZWxlbWVudFtzY3JvbGxLZXldO1xuICAgICAgICBzZXRTY3JvbGxPZmZzZXQob2Zmc2V0KTtcbiAgICAgIH07XG5cbiAgICAgIG9uU2Nyb2xsKCk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsLCB7XG4gICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpO1xuICAgICAgfTtcbiAgICB9LCBbZWxlbWVudCwgc2Nyb2xsS2V5XSk7XG5cbiAgICB2YXIgX2NhbGN1bGF0ZVJhbmdlID0gY2FsY3VsYXRlUmFuZ2UobGF0ZXN0UmVmLmN1cnJlbnQpLFxuICAgICAgICBzdGFydCA9IF9jYWxjdWxhdGVSYW5nZS5zdGFydCxcbiAgICAgICAgZW5kID0gX2NhbGN1bGF0ZVJhbmdlLmVuZDtcblxuICAgIHZhciBpbmRleGVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmFuZ2VFeHRyYWN0b3Ioe1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBvdmVyc2Nhbjogb3ZlcnNjYW4sXG4gICAgICAgIHNpemU6IG1lYXN1cmVtZW50cy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0sIFtzdGFydCwgZW5kLCBvdmVyc2NhbiwgbWVhc3VyZW1lbnRzLmxlbmd0aCwgcmFuZ2VFeHRyYWN0b3JdKTtcbiAgICB2YXIgbWVhc3VyZVNpemVSZWYgPSBSZWFjdC51c2VSZWYobWVhc3VyZVNpemUpO1xuICAgIG1lYXN1cmVTaXplUmVmLmN1cnJlbnQgPSBtZWFzdXJlU2l6ZTtcbiAgICB2YXIgdmlydHVhbEl0ZW1zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmlydHVhbEl0ZW1zID0gW107XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGssIGxlbikge1xuICAgICAgICB2YXIgaSA9IGluZGV4ZXNba107XG4gICAgICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcblxuICAgICAgICB2YXIgaXRlbSA9IF9leHRlbmRzKF9leHRlbmRzKHt9LCBtZWFzdXJlbWVudCksIHt9LCB7XG4gICAgICAgICAgbWVhc3VyZVJlZjogZnVuY3Rpb24gbWVhc3VyZVJlZihlbCkge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgIHZhciBtZWFzdXJlZFNpemUgPSBtZWFzdXJlU2l6ZVJlZi5jdXJyZW50KGVsLCBob3Jpem9udGFsKTtcblxuICAgICAgICAgICAgICBpZiAobWVhc3VyZWRTaXplICE9PSBpdGVtLnNpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbE9mZnNldCA9IGxhdGVzdFJlZi5jdXJyZW50LnNjcm9sbE9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0YXJ0IDwgX3Njcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdFNjcm9sbFRvRm4oX3Njcm9sbE9mZnNldCArIChtZWFzdXJlZFNpemUgLSBpdGVtLnNpemUpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXNSZWYuY3VycmVudC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIHNldE1lYXN1cmVkQ2FjaGUoZnVuY3Rpb24gKG9sZCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKF9leHRlbmRzKHt9LCBvbGQpLCB7fSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbaXRlbS5rZXldID0gbWVhc3VyZWRTaXplLCBfZXh0ZW5kczIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlydHVhbEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrID0gMCwgbGVuID0gaW5kZXhlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICBfbG9vcChrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpcnR1YWxJdGVtcztcbiAgICB9LCBbaW5kZXhlcywgZGVmYXVsdFNjcm9sbFRvRm4sIGhvcml6b250YWwsIG1lYXN1cmVtZW50c10pO1xuICAgIHZhciBtb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc2V0TWVhc3VyZWRDYWNoZSh7fSk7XG4gICAgICB9XG5cbiAgICAgIG1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSwgW2VzdGltYXRlU2l6ZV0pO1xuICAgIHZhciBzY3JvbGxUb09mZnNldCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0b09mZnNldCwgX3RlbXApIHtcbiAgICAgIHZhciBfcmVmMiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICAgIF9yZWYyJGFsaWduID0gX3JlZjIuYWxpZ24sXG4gICAgICAgICAgYWxpZ24gPSBfcmVmMiRhbGlnbiA9PT0gdm9pZCAwID8gJ3N0YXJ0JyA6IF9yZWYyJGFsaWduO1xuXG4gICAgICB2YXIgX2xhdGVzdFJlZiRjdXJyZW50ID0gbGF0ZXN0UmVmLmN1cnJlbnQsXG4gICAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gX2xhdGVzdFJlZiRjdXJyZW50LnNjcm9sbE9mZnNldCxcbiAgICAgICAgICBvdXRlclNpemUgPSBfbGF0ZXN0UmVmJGN1cnJlbnQub3V0ZXJTaXplO1xuXG4gICAgICBpZiAoYWxpZ24gPT09ICdhdXRvJykge1xuICAgICAgICBpZiAodG9PZmZzZXQgPD0gc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgICAgYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICB9IGVsc2UgaWYgKHRvT2Zmc2V0ID49IHNjcm9sbE9mZnNldCArIG91dGVyU2l6ZSkge1xuICAgICAgICAgIGFsaWduID0gJ2VuZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBzY3JvbGxUb0ZuKHRvT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHNjcm9sbFRvRm4odG9PZmZzZXQgLSBvdXRlclNpemUpO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgc2Nyb2xsVG9Gbih0b09mZnNldCAtIG91dGVyU2l6ZSAvIDIpO1xuICAgICAgfVxuICAgIH0sIFtzY3JvbGxUb0ZuXSk7XG4gICAgdmFyIHRyeVNjcm9sbFRvSW5kZXggPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5kZXgsIF90ZW1wMikge1xuICAgICAgdmFyIF9yZWYzID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMixcbiAgICAgICAgICBfcmVmMyRhbGlnbiA9IF9yZWYzLmFsaWduLFxuICAgICAgICAgIGFsaWduID0gX3JlZjMkYWxpZ24gPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9yZWYzJGFsaWduLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMywgW1wiYWxpZ25cIl0pO1xuXG4gICAgICB2YXIgX2xhdGVzdFJlZiRjdXJyZW50MiA9IGxhdGVzdFJlZi5jdXJyZW50LFxuICAgICAgICAgIG1lYXN1cmVtZW50cyA9IF9sYXRlc3RSZWYkY3VycmVudDIubWVhc3VyZW1lbnRzLFxuICAgICAgICAgIHNjcm9sbE9mZnNldCA9IF9sYXRlc3RSZWYkY3VycmVudDIuc2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgIG91dGVyU2l6ZSA9IF9sYXRlc3RSZWYkY3VycmVudDIub3V0ZXJTaXplO1xuICAgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW01hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBzaXplIC0gMSkpXTtcblxuICAgICAgaWYgKCFtZWFzdXJlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGlmIChtZWFzdXJlbWVudC5lbmQgPj0gc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgICAgICAgYWxpZ24gPSAnZW5kJztcbiAgICAgICAgfSBlbHNlIGlmIChtZWFzdXJlbWVudC5zdGFydCA8PSBzY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICBhbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0b09mZnNldCA9IGFsaWduID09PSAnY2VudGVyJyA/IG1lYXN1cmVtZW50LnN0YXJ0ICsgbWVhc3VyZW1lbnQuc2l6ZSAvIDIgOiBhbGlnbiA9PT0gJ2VuZCcgPyBtZWFzdXJlbWVudC5lbmQgOiBtZWFzdXJlbWVudC5zdGFydDtcbiAgICAgIHNjcm9sbFRvT2Zmc2V0KHRvT2Zmc2V0LCBfZXh0ZW5kcyh7XG4gICAgICAgIGFsaWduOiBhbGlnblxuICAgICAgfSwgcmVzdCkpO1xuICAgIH0sIFtzY3JvbGxUb09mZnNldCwgc2l6ZV0pO1xuICAgIHZhciBzY3JvbGxUb0luZGV4ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGRvIGEgZG91YmxlIHJlcXVlc3QgaGVyZSBiZWNhdXNlIG9mXG4gICAgICAvLyBkeW5hbWljIHNpemVzIHdoaWNoIGNhbiBjYXVzZSBvZmZzZXQgc2hpZnRcbiAgICAgIC8vIGFuZCBlbmQgdXAgaW4gdGhlIHdyb25nIHNwb3QuIFVuZm9ydHVuYXRlbHksXG4gICAgICAvLyB3ZSBjYW4ndCBrbm93IGFib3V0IHRob3NlIGR5bmFtaWMgc2l6ZXMgdW50aWxcbiAgICAgIC8vIHdlIHRyeSBhbmQgcmVuZGVyIHRoZW0uIFNvIGRvdWJsZSBkb3duIVxuICAgICAgdHJ5U2Nyb2xsVG9JbmRleC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5U2Nyb2xsVG9JbmRleC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSwgW3RyeVNjcm9sbFRvSW5kZXhdKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlydHVhbEl0ZW1zOiB2aXJ0dWFsSXRlbXMsXG4gICAgICB0b3RhbFNpemU6IHRvdGFsU2l6ZSxcbiAgICAgIHNjcm9sbFRvT2Zmc2V0OiBzY3JvbGxUb09mZnNldCxcbiAgICAgIHNjcm9sbFRvSW5kZXg6IHNjcm9sbFRvSW5kZXgsXG4gICAgICBtZWFzdXJlOiBtZWFzdXJlXG4gICAgfTtcbiAgfVxuXG4gIHZhciBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uIGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKGxvdywgaGlnaCwgZ2V0Q3VycmVudFZhbHVlLCB2YWx1ZSkge1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAvIDIgfCAwO1xuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGdldEN1cnJlbnRWYWx1ZShtaWRkbGUpO1xuXG4gICAgICBpZiAoY3VycmVudFZhbHVlIDwgdmFsdWUpIHtcbiAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gdmFsdWUpIHtcbiAgICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb3cgPiAwKSB7XG4gICAgICByZXR1cm4gbG93IC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVJhbmdlKF9yZWY0KSB7XG4gICAgdmFyIG1lYXN1cmVtZW50cyA9IF9yZWY0Lm1lYXN1cmVtZW50cyxcbiAgICAgICAgb3V0ZXJTaXplID0gX3JlZjQub3V0ZXJTaXplLFxuICAgICAgICBzY3JvbGxPZmZzZXQgPSBfcmVmNC5zY3JvbGxPZmZzZXQ7XG4gICAgdmFyIHNpemUgPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcblxuICAgIHZhciBnZXRPZmZzZXQgPSBmdW5jdGlvbiBnZXRPZmZzZXQoaW5kZXgpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICAgIH07XG5cbiAgICB2YXIgc3RhcnQgPSBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCgwLCBzaXplLCBnZXRPZmZzZXQsIHNjcm9sbE9mZnNldCk7XG4gICAgdmFyIGVuZCA9IHN0YXJ0O1xuXG4gICAgd2hpbGUgKGVuZCA8IHNpemUgJiYgbWVhc3VyZW1lbnRzW2VuZF0uZW5kIDwgc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgICBlbmQrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmRcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0cy5kZWZhdWx0UmFuZ2VFeHRyYWN0b3IgPSBkZWZhdWx0UmFuZ2VFeHRyYWN0b3I7XG4gIGV4cG9ydHMudXNlVmlydHVhbCA9IHVzZVZpcnR1YWw7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXZpcnR1YWwuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-virtual/dist/react-virtual.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-virtual/index.js":
/*!*********************************************!*\
  !*** ./node_modules/react-virtual/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("if (false) {} else {\n  module.exports = __webpack_require__(/*! ./dist/react-virtual.development.js */ \"(ssr)/./node_modules/react-virtual/dist/react-virtual.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVhbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsdUpBQStEO0FBQ2pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFpcmMvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVhbC9pbmRleC5qcz8wYWVkIl0sInNvdXJjZXNDb250ZW50IjpbImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3JlYWN0LXZpcnR1YWwucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcmVhY3QtdmlydHVhbC5kZXZlbG9wbWVudC5qcycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-virtual/index.js\n");

/***/ })

};
;